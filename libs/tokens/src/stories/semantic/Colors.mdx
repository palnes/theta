import { Meta } from '@storybook/addon-docs/blocks';
import { getSemanticColors, getSemanticColorsFromDocs } from '../helpers/semanticTokenHelpers';
import { Section } from '../helpers/DocComponents';
import { TokenReferenceTable } from '../helpers/TokenReferenceTable';
import { useDocumentationData } from '../helpers/useDocumentationData';

<Meta title="Token Reference/Semantic/Colors" />

# Semantic Color System

Purpose-driven colors that adapt based on the current theme. These colors reference primitive values to provide meaning and context.

export const ColorSection = ({ category, colors, isText = false }) => {
  const renderColorItem = (key, states, pathPrefix) => {
    // Check if this is a token object with $type and $value
    if (states && typeof states === 'object' && states.$type && states.$value) {
      // It's a single token, render it
      const cssVar = states.cssVariable || `--sys-color-${pathPrefix}`;
      const jsPath = states.jsPath ? states.jsPath.replace('tokens.', '') : `sys.color.${pathPrefix.replace(/-/g, '.')}`;
      
      return (
        <div key={key}>
          <div
            style={{
              height: 80,
              backgroundColor: isText ? '#f5f5f5' : `var(${cssVar})`,
              border: '1px solid rgba(0, 0, 0, 0.1)',
              borderRadius: 8,
              marginBottom: 8,
              ...(isText && {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: `var(${cssVar})`,
                fontWeight: 500,
              })
            }}
          >
            {isText && `${key.charAt(0).toUpperCase() + key.slice(1)} Text`}
          </div>
          <div style={{ fontSize: 12 }}>
            <strong style={{ textTransform: 'capitalize' }}>{key}</strong>
            <code style={{ display: 'block', fontSize: 11, color: '#666', marginTop: 4 }}>
              {cssVar}
            </code>
            <code style={{ display: 'block', fontSize: 11, color: '#999', marginTop: 2 }}>
              {jsPath}
            </code>
          </div>
        </div>
      );
    } else if (states && typeof states === 'object' && states.default) {
      // It has states, render each state
      return Object.entries(states).map(([state, token]) => {
        const cssVar = token.cssVariable || `--sys-color-${pathPrefix}-${state}`;
        const jsPath = token.jsPath ? token.jsPath.replace('tokens.', '') : `sys.color.${pathPrefix}.${state}`;
        
        return (
          <div key={`${key}-${state}`}>
            <div
              style={{
                height: 80,
                backgroundColor: isText ? '#f5f5f5' : `var(${cssVar})`,
                border: '1px solid rgba(0, 0, 0, 0.1)',
                borderRadius: 8,
                marginBottom: 8,
                ...(isText && {
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  color: `var(${cssVar})`,
                  fontWeight: 500,
                })
              }}
            >
              {isText && `${key} (${state})`}
            </div>
            <div style={{ fontSize: 12 }}>
              <strong style={{ textTransform: 'capitalize' }}>{key}</strong>
              <div style={{ fontSize: 10, color: '#888' }}>{state}</div>
              <code style={{ display: 'block', fontSize: 11, color: '#666', marginTop: 4 }}>
                {cssVar}
              </code>
              <code style={{ display: 'block', fontSize: 11, color: '#999', marginTop: 2 }}>
                {jsPath}
              </code>
            </div>
          </div>
        );
      });
    } else if (states && typeof states === 'object') {
      // It's a nested category, recurse
      return Object.entries(states).flatMap(([subKey, subStates]) => 
        renderColorItem(subKey, subStates, `${pathPrefix}-${subKey}`)
      );
    } else {
      // It's a simple value (legacy format)
      const cssVar = `--sys-color-${pathPrefix}`;
      const jsPath = `sys.color.${pathPrefix.replace(/-/g, '.')}`;
      
      return (
        <div key={key}>
          <div
            style={{
              height: 80,
              backgroundColor: isText ? '#f5f5f5' : `var(${cssVar})`,
              border: '1px solid rgba(0, 0, 0, 0.1)',
              borderRadius: 8,
              marginBottom: 8,
              ...(isText && {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: `var(${cssVar})`,
                fontWeight: 500,
              })
            }}
          >
            {isText && `${key.charAt(0).toUpperCase() + key.slice(1)} Text`}
          </div>
          <div style={{ fontSize: 12 }}>
            <strong style={{ textTransform: 'capitalize' }}>{key}</strong>
            <code style={{ display: 'block', fontSize: 11, color: '#666', marginTop: 4 }}>
              {cssVar}
            </code>
            <code style={{ display: 'block', fontSize: 11, color: '#999', marginTop: 2 }}>
              {jsPath}
            </code>
          </div>
        </div>
      );
    }
  };

  return (
    <div style={{ marginBottom: 48 }}>
      <h2>{category.label}</h2>
      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: 16 }}>
        {Object.entries(colors).flatMap(([key, value]) => 
          renderColorItem(key, value, `${category.name}-${key}`)
        )}
      </div>
    </div>
  );
};

export const AllSemanticColors = () => {
  const { data, loading, error } = useDocumentationData();
  
  if (loading) return <div>Loading semantic colors...</div>;
  if (error) return <div>Error loading colors: {error}</div>;
  if (!data) return null;
  
  const categories = getSemanticColorsFromDocs(data.sys?.color || []);
  
  return (
    <>
      {categories.map(category => (
        <ColorSection 
          key={category.name} 
          category={category} 
          colors={category.colors} 
          isText={category.name === 'text'}
        />
      ))}
    </>
  );
};

<AllSemanticColors />

> For detailed information about token architecture, usage patterns, and state nesting, see the [Token Guide](/?path=/docs/getting-started-token-guide--docs).

## Semantic Categories
Our semantic colors express intent, not components:
- **action**: Interactive elements (buttons, links)
- **surface**: Background surfaces
- **text**: Text colors
- **border**: Border colors
- **icon**: Icon colors
- **state**: Success, warning, error, info states
- **semantic**: Status colors (success, warning, error)
- **interaction**: Subtle interactive surfaces

## Reference Table

Complete listing of all semantic color tokens:

<TokenReferenceTable tier="sys" category="color" />