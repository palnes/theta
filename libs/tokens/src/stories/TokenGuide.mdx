import { Meta } from '@storybook/addon-docs/blocks';
import { Warning } from './helpers/DocComponents';

<Meta title="Getting Started/Token Guide" />

# Token Guide

Design tokens are reusable design decisions expressed as data. They include colors, spacing, typography, and other visual properties that can be transformed into platform-specific code.

This guide covers the token architecture, naming conventions, and usage patterns in Theta.

## What Are Design Tokens?

Instead of hardcoding values like `color: #0969da`, design tokens use semantic references like `color: var(--sys-color-action-primary)`.

Benefits:
- Consistent values across components
- Single source of truth for design decisions
- Theme switching capability
- Platform-agnostic definitions

## How Theta's Token System Works

Theta uses a three-tier token architecture:

1. **Reference tokens** define your raw values (all the colors in your palette)
2. **Semantic tokens** assign meaning to those values (what "primary action" means)
3. **Component tokens** specify how components use those meanings (button backgrounds)

This structure lets you change how something looks (reference), what it means (semantic), or how it's used (component) independently.

## Table of Contents

- [Three-Tier Architecture](#three-tier-architecture)
- [Token Format](#token-format)
- [Naming Conventions](#naming-conventions)
- [Working with Tokens](#working-with-tokens)
- [Platform Outputs](#platform-outputs)
- [Quick Reference](#quick-reference)

---

## Three-Tier Architecture

The token system uses a hierarchical structure where each tier references the tier below it:

1. **Reference tokens**: Raw values (colors, dimensions, fonts)
2. **Semantic tokens**: Design decisions with intent
3. **Component tokens**: Component-specific implementations

Multiple components share semantic tokens, which reference a controlled set of primitives.

### Primitive Tokens (ref.*)

Raw design values without semantic meaning. These form your design palette - all possible values in your system.

```json
// Simple examples:
"ref.color.blue.600": "#0969da"
"ref.spacing.16": "16px"
"ref.fontSize.14": "14px"
```

These are raw values without semantic meaning.

### Semantic Tokens (sys.*)

Design intent and meaning. These express **what** something is conceptually, not **how** it looks.

```json
// What they mean:
"sys.color.action.primary": "{ref.color.blue.600}"
"sys.color.text.muted": "{ref.color.gray.600}"
"sys.spacing.md": "{ref.spacing.16}"
```

Semantic tokens map design intent to primitive values.

### Component Tokens (cmp.*)

Implementation details. These define **how** components use semantic values.

```json
// How they're used:
"cmp.button.background.primary": "{sys.color.action.primary}"
"cmp.button.text.primary": "{sys.color.text.onAction}"
"cmp.input.border.default": "{sys.color.border.default}"
```

Component tokens specify how components use semantic tokens.

### Why This Architecture?

Example of the token hierarchy:

```json
// 1. One primitive color
"ref.color.blue.600": "#0969da"

// 2. Used by multiple semantic tokens
"sys.color.action.primary": "{ref.color.blue.600}"
"sys.color.link.default": "{ref.color.blue.600}"
"sys.color.focus.ring": "{ref.color.blue.600}"

// 3. Used by many components
"cmp.button.background.primary": "{sys.color.action.primary}"
"cmp.link.text.default": "{sys.color.link.default}"
"cmp.input.border.focus": "{sys.color.focus.ring}"
"cmp.checkbox.background.checked": "{sys.color.action.primary}"
```

Changing `ref.color.blue.600` updates all tokens that reference it. Different semantic tokens can map to the same primitive, and components can override semantic defaults when needed.

### Reference Rules

Tokens can only reference tokens from higher tiers. This one-way flow prevents circular dependencies and maintains clear architecture.

| From | Can Reference | Cannot Reference |
|------|---------------|------------------|
| Component (cmp.*) | sys.*, ref.* | other cmp.* |
| Semantic (sys.*) | ref.* | cmp.*, other sys.* |
| Primitive (ref.*) | nothing | any tokens |

<Warning>
  Token references to non-existent tokens will cause build failures. The tier hierarchy rules are architectural guidelines - they're not currently enforced by tooling but following them ensures maintainable token architecture.
</Warning>

---

## Token Format

Theta uses the [Design Tokens Community Group (DTCG) format](https://github.com/design-tokens/community-group). This specification uses JSON with special properties (prefixed with `$`) to define token metadata.

### Core Properties

#### $value (required)

The token's value. Can be a literal value or a reference to another token.

```json
// Literal value
"blue-600": {
  "$type": "color",
  "$value": "#0969da"
}

// Reference value  
"primary": {
  "$value": "{ref.color.blue.600}"
}
```

#### $type (required for literals only)

Specifies the token type for proper transformation and validation. Tokens that reference other tokens inherit the type automatically.

| Type | Example Value | Usage |
|------|---------------|-------|
| color | #0969da | Color values |
| dimension | 16px | Spacing, sizes |
| fontFamily | Inter | Font families |
| fontWeight | 600 | Font weights |
| fontSize | 14px | Font sizes |
| lineHeight | 1.5 | Line heights |
| letterSpacing | 0.02em | Letter spacing |
| shadow | composite | Box shadows |
| typography | composite | Text styles |

```json
// Primitive token WITH $type (required)
"ref.color.blue.600": {
  "$type": "color",
  "$value": "#0969da"
}

// Semantic token WITHOUT $type (inherited)
"sys.color.primary": {
  "$value": "{ref.color.blue.600}"
  // Inherits "color" type from reference
}
```

#### $description (optional)

Human-readable description of the token's purpose.

```json
"action-primary": {
  "$value": "{ref.color.blue.600}",
  "$description": "Primary color for interactive elements"
}
```

### Reference Syntax

Use curly braces to reference other tokens:

```
{tier.category.path}

// Examples:
{ref.color.blue.600}
{sys.color.action.primary.default}
```

---

## Naming Conventions

Token names follow a consistent hierarchical pattern for predictability and organization.

### Naming Pattern

```
[tier].[category].[subcategory].[variant].[property].[state]
```

### Examples by Tier

**Primitive (ref.*)**
- `ref.color.blue.600`
- `ref.spacing.16`
- `ref.fontSize.14`

**Semantic (sys.*)**
- `sys.color.action.primary.default`
- `sys.color.surface.raised.hover`
- `sys.spacing.sm`

**Component (cmp.*)**
- `cmp.button.color.primary.background.default`
- `cmp.input.color.error.border.default`
- `cmp.badge.radius.default`

### State Nesting

States are always nested as the final level, never concatenated into property names.

```json
// ✅ Correct - States nested
{
  "background": {
    "default": { "$value": "#fff" },
    "hover": { "$value": "#f5f5f5" },
    "active": { "$value": "#e0e0e0" },
    "disabled": { "$value": "#ccc" }
  }
}

// ❌ Incorrect - States concatenated
{
  "background": { "$value": "#fff" },
  "backgroundHover": { "$value": "#f5f5f5" }
}
```

### Common States

| State | Description | Use Case |
|-------|-------------|----------|
| default | Base state | Normal appearance |
| hover | Mouse over | Desktop hover effects |
| active | Pressed/active | During interaction |
| focus | Keyboard focus | Accessibility |
| disabled | Unavailable | Non-interactive |
| selected | Selected item | Active selection |

---

## Working with Tokens

Practical steps for developing and maintaining tokens.

### File Organization

```
tokens/
├── primitives/     # Raw values (ref.*)
│   ├── color.json
│   ├── dimension.json
│   ├── typography.json
│   └── number.json
├── semantic/       # Intent-based (sys.*)
│   ├── color.json
│   ├── spacing.json
│   ├── typography.json
│   ├── radius.json
│   ├── shadow.json
│   └── zIndex.json
└── component/      # Component-specific (cmp.*)
    ├── button.json
    ├── input.json
    ├── badge.json
    └── checkbox.json
```

### Adding New Tokens

1. **Identify the tier** - Is this a raw value, design intent, or component implementation?

2. **Add to appropriate file**:
   ```json
   // primitives/color.json
   {
     "ref": {
       "color": {
         "purple": {
           "600": {
             "$type": "color",
             "$value": "#7c3aed"
           }
         }
       }
     }
   }
   ```

3. **Create semantic mapping** (if adding primitive):
   ```json
   // semantic/color.json
   {
     "sys": {
       "color": {
         "action": {
           "tertiary": {
             "default": {
               "$value": "{ref.color.purple.600}"
             }
           }
         }
       }
     }
   }
   ```

4. **Build and test**:
   ```bash
   # Build tokens
   yarn workspace @theta/tokens build
   
   # Check generated files
   ls dist/css/tokens.css
   ls dist/js/tokens.js
   ```

### Testing Changes

Always validate your changes before committing:

```bash
# Run the build
yarn workspace @theta/tokens build

# Run tests if available
yarn workspace @theta/tokens test

# Check Storybook for visual changes
yarn storybook
```

### Common Patterns

#### Color State Variations
```json
{
  "action": {
    "primary": {
      "default": { "$value": "{ref.color.blue.600}" },
      "hover": { "$value": "{ref.color.blue.700}" },
      "active": { "$value": "{ref.color.blue.800}" },
      "disabled": { "$value": "{ref.color.gray.400}" }
    }
  }
}
```

#### Spacing Scale
Use consistent T-shirt sizing:

| Size | Token | Typical Value | Usage |
|------|-------|---------------|-------|
| xs | sys.spacing.xs | 4px | Tight spacing |
| sm | sys.spacing.sm | 8px | Related items |
| md | sys.spacing.md | 16px | Default spacing |
| lg | sys.spacing.lg | 24px | Section spacing |
| xl | sys.spacing.xl | 32px | Major sections |

#### Typography Composition
```json
{
  "heading": {
    "large": {
      "$type": "typography",
      "$value": {
        "fontFamily": "{ref.fontFamily.sans}",
        "fontSize": "{ref.fontSize.32}",
        "fontWeight": "{ref.fontWeight.bold}",
        "lineHeight": "{ref.lineHeight.tight}"
      }
    }
  }
}
```

---

## Platform Outputs

Tokens are automatically transformed into platform-specific formats during the build process.

### Web (CSS Variables)

```css
/* Input token */
sys.color.action.primary.default

/* Output CSS */
--sys-color-action-primary-default: #0969da;
```

### JavaScript/TypeScript

```javascript
// Nested object structure
tokens.sys.color.action.primary.default // "#0969da"

// TypeScript types included
import { tokens } from '@theta/tokens';
```

### React Native

```javascript
// Flattened camelCase
sysColorActionPrimaryDefault // "#0969da"
```

---

## Quick Reference

### Build Commands

```bash
# Build all token formats
yarn workspace @theta/tokens build

# Watch mode for development
yarn workspace @theta/tokens build:watch
```

### Validation Rules

1. **Valid References** - All token references must point to existing tokens
2. **Type Consistency** - Values must match their declared type
3. **No Circular References** - Tokens cannot reference themselves directly or indirectly
4. **Tier Hierarchy** - Follow the one-way reference flow

### Troubleshooting

| Error | Cause | Solution |
|-------|-------|----------|
| Invalid reference | Token references non-existent token | Check token path and spelling |
| Circular reference | Tokens reference each other | Break the cycle, use primitives |
| Type mismatch | Wrong $type for value format | Match type to value structure |
| Missing $type | Literal value without type | Add $type to primitive tokens |

---

## Best Practices

1. **Use semantic tokens in components** - Components should rarely reference primitives directly
2. **Document token purpose** - Add $description to semantic and component tokens
3. **Follow naming patterns** - Consistency makes tokens predictable
4. **Test before committing** - Always run build to catch errors
5. **Think about themes** - Semantic tokens enable theme switching

## Next Steps

- Browse existing tokens in the sidebar under "Token Reference"
- Review component examples to see tokens in use
- Create a test token following this guide
- Join discussions about token architecture improvements