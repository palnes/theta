import { Meta } from '@storybook/addon-docs';
import { Warning } from './helpers/DocComponents';

<Meta title="Getting Started/Token Guide" />

# Token Guide

Design tokens are the heart of Theta's design system. They're the smallest pieces of our design language - colors, spacing, typography, and more - stored as data that can be transformed into code for any platform.

This guide will teach you how to work with Theta's token system, whether you're building components, creating themes, or contributing to the design system itself.

## What Are Design Tokens?

Instead of hardcoding values like `color: #0969da` throughout your components, design tokens let you reference semantic values like `color: var(--sys-color-action-primary)`. This abstraction provides:

- **Consistency**: Use the same values everywhere without copy-pasting hex codes
- **Maintainability**: Change a color in one place, update your entire system
- **Theming**: Swap semantic values to create dark mode or brand variations
- **Cross-platform**: Same tokens work on web, iOS, and Android

## How Theta's Token System Works

We use a three-tier architecture that mirrors how designers think about design systems:

1. **Primitive tokens** define your raw values (all the colors in your palette)
2. **Semantic tokens** assign meaning to those values (what "primary action" means)
3. **Component tokens** specify how components use those meanings (button backgrounds)

This structure lets you change how something looks (primitives), what it means (semantic), or how it's used (component) independently.

## Table of Contents

- [Three-Tier Architecture](#three-tier-architecture)
- [Token Format](#token-format)
- [Naming Conventions](#naming-conventions)
- [Working with Tokens](#working-with-tokens)
- [Platform Outputs](#platform-outputs)
- [Quick Reference](#quick-reference)

---

## Three-Tier Architecture

Our token system follows a hierarchical structure inspired by the design token pyramid, where each tier builds upon the previous one. This creates a system that's both flexible and maintainable.

### The Token Pyramid

Think of tokens as a pyramid with three levels:
- **Wide base**: Many primitive values (colors, sizes, fonts)
- **Middle layer**: Fewer semantic tokens (meanings and intentions)  
- **Narrow top**: Specific component implementations

This narrowing ensures consistency - many components share the same semantic tokens, which reference a controlled set of primitives.

### Primitive Tokens (ref.*)

Raw design values without semantic meaning. These form your design palette - all possible values in your system.

```json
// Simple examples:
"ref.color.blue.600": "#0969da"
"ref.spacing.16": "16px"
"ref.fontSize.14": "14px"
```

Think of these as your "art supplies" - the raw materials you'll use to build your design.

### Semantic Tokens (sys.*)

Design intent and meaning. These express **what** something is conceptually, not **how** it looks.

```json
// What they mean:
"sys.color.action.primary": "{ref.color.blue.600}"
"sys.color.text.muted": "{ref.color.gray.600}"
"sys.spacing.md": "{ref.spacing.16}"
```

These are your "design decisions" - primary actions are blue, muted text is gray, medium spacing is 16px.

### Component Tokens (cmp.*)

Implementation details. These define **how** components use semantic values.

```json
// How they're used:
"cmp.button.background.primary": "{sys.color.action.primary}"
"cmp.button.text.primary": "{sys.color.text.onAction}"
"cmp.input.border.default": "{sys.color.border.default}"
```

These are your "blueprints" - buttons use primary action color for their background, inputs use default border color.

### Why This Architecture?

Let's see how this pyramid benefits us with a real example:

```json
// 1. One primitive color
"ref.color.blue.600": "#0969da"

// 2. Used by multiple semantic tokens
"sys.color.action.primary": "{ref.color.blue.600}"
"sys.color.link.default": "{ref.color.blue.600}"
"sys.color.focus.ring": "{ref.color.blue.600}"

// 3. Used by many components
"cmp.button.background.primary": "{sys.color.action.primary}"
"cmp.link.text.default": "{sys.color.link.default}"
"cmp.input.border.focus": "{sys.color.focus.ring}"
"cmp.checkbox.background.checked": "{sys.color.action.primary}"
```

**The power**: Change `ref.color.blue.600` to a different blue, and your entire system updates consistently. Want different colors for links vs buttons? Change the semantic layer. Need a special button variant? Modify only the component token.

### Reference Rules

Tokens can only reference tokens from higher tiers. This one-way flow prevents circular dependencies and maintains clear architecture.

| From | Can Reference | Cannot Reference |
|------|---------------|------------------|
| Component (cmp.*) | sys.*, ref.* | other cmp.* |
| Semantic (sys.*) | ref.* | cmp.*, other sys.* |
| Primitive (ref.*) | nothing | any tokens |

<Warning>
  Token references to non-existent tokens will cause build failures. The tier hierarchy rules are architectural guidelines - they're not currently enforced by tooling but following them ensures maintainable token architecture.
</Warning>

---

## Token Format

Theta uses the [Design Tokens Community Group (DTCG) format](https://github.com/design-tokens/community-group) for defining tokens. This is an industry-standard specification that ensures our tokens are portable, tool-agnostic, and future-proof. By following DTCG, our tokens can be consumed by Style Dictionary, Figma plugins, and other design tools without custom transformations. The format uses JSON with special properties (prefixed with `$`) to define token metadata alongside their values.

### Core Properties

#### $value (required)

The token's value. Can be a literal value or a reference to another token.

```json
// Literal value
"blue-600": {
  "$type": "color",
  "$value": "#0969da"
}

// Reference value  
"primary": {
  "$value": "{ref.color.blue.600}"
}
```

#### $type (required for literals only)

Specifies the token type for proper transformation and validation. Tokens that reference other tokens inherit the type automatically.

| Type | Example Value | Usage |
|------|---------------|-------|
| color | #0969da | Color values |
| dimension | 16px | Spacing, sizes |
| fontFamily | Inter | Font families |
| fontWeight | 600 | Font weights |
| fontSize | 14px | Font sizes |
| lineHeight | 1.5 | Line heights |
| letterSpacing | 0.02em | Letter spacing |
| shadow | composite | Box shadows |
| typography | composite | Text styles |

```json
// Primitive token WITH $type (required)
"ref.color.blue.600": {
  "$type": "color",
  "$value": "#0969da"
}

// Semantic token WITHOUT $type (inherited)
"sys.color.primary": {
  "$value": "{ref.color.blue.600}"
  // Inherits "color" type from reference
}
```

#### $description (optional)

Human-readable description of the token's purpose.

```json
"action-primary": {
  "$value": "{ref.color.blue.600}",
  "$description": "Primary color for interactive elements"
}
```

### Reference Syntax

Use curly braces to reference other tokens:

```
{tier.category.path}

// Examples:
{ref.color.blue.600}
{sys.color.action.primary.default}
```

---

## Naming Conventions

Token names follow a consistent hierarchical pattern for predictability and organization.

### Naming Pattern

```
[tier].[category].[subcategory].[variant].[property].[state]
```

### Examples by Tier

**Primitive (ref.*)**
- `ref.color.blue.600`
- `ref.spacing.16`
- `ref.fontSize.14`

**Semantic (sys.*)**
- `sys.color.action.primary.default`
- `sys.color.surface.raised.hover`
- `sys.spacing.sm`

**Component (cmp.*)**
- `cmp.button.color.primary.background.default`
- `cmp.input.color.error.border.default`
- `cmp.badge.radius.default`

### State Nesting

States are always nested as the final level, never concatenated into property names.

```json
// ✅ Correct - States nested
{
  "background": {
    "default": { "$value": "#fff" },
    "hover": { "$value": "#f5f5f5" },
    "active": { "$value": "#e0e0e0" },
    "disabled": { "$value": "#ccc" }
  }
}

// ❌ Incorrect - States concatenated
{
  "background": { "$value": "#fff" },
  "backgroundHover": { "$value": "#f5f5f5" }
}
```

### Common States

| State | Description | Use Case |
|-------|-------------|----------|
| default | Base state | Normal appearance |
| hover | Mouse over | Desktop hover effects |
| active | Pressed/active | During interaction |
| focus | Keyboard focus | Accessibility |
| disabled | Unavailable | Non-interactive |
| selected | Selected item | Active selection |

---

## Working with Tokens

Practical steps for developing and maintaining tokens.

### File Organization

```
tokens/
├── primitives/     # Raw values (ref.*)
│   ├── color.json
│   ├── dimension.json
│   ├── typography.json
│   └── number.json
├── semantic/       # Intent-based (sys.*)
│   ├── color.json
│   ├── spacing.json
│   ├── typography.json
│   ├── radius.json
│   ├── shadow.json
│   └── zIndex.json
└── component/      # Component-specific (cmp.*)
    ├── button.json
    ├── input.json
    ├── badge.json
    └── checkbox.json
```

### Adding New Tokens

1. **Identify the tier** - Is this a raw value, design intent, or component implementation?

2. **Add to appropriate file**:
   ```json
   // primitives/color.json
   {
     "ref": {
       "color": {
         "purple": {
           "600": {
             "$type": "color",
             "$value": "#7c3aed"
           }
         }
       }
     }
   }
   ```

3. **Create semantic mapping** (if adding primitive):
   ```json
   // semantic/color.json
   {
     "sys": {
       "color": {
         "action": {
           "tertiary": {
             "default": {
               "$value": "{ref.color.purple.600}"
             }
           }
         }
       }
     }
   }
   ```

4. **Build and test**:
   ```bash
   # Build tokens
   yarn workspace @theta/tokens build
   
   # Check generated files
   ls dist/css/tokens.css
   ls dist/js/tokens.js
   ```

### Testing Changes

Always validate your changes before committing:

```bash
# Run the build
yarn workspace @theta/tokens build

# Run tests if available
yarn workspace @theta/tokens test

# Check Storybook for visual changes
yarn storybook
```

### Common Patterns

#### Color State Variations
```json
{
  "action": {
    "primary": {
      "default": { "$value": "{ref.color.blue.600}" },
      "hover": { "$value": "{ref.color.blue.700}" },
      "active": { "$value": "{ref.color.blue.800}" },
      "disabled": { "$value": "{ref.color.gray.400}" }
    }
  }
}
```

#### Spacing Scale
Use consistent T-shirt sizing:

| Size | Token | Typical Value | Usage |
|------|-------|---------------|-------|
| xs | sys.spacing.xs | 4px | Tight spacing |
| sm | sys.spacing.sm | 8px | Related items |
| md | sys.spacing.md | 16px | Default spacing |
| lg | sys.spacing.lg | 24px | Section spacing |
| xl | sys.spacing.xl | 32px | Major sections |

#### Typography Composition
```json
{
  "heading": {
    "large": {
      "$type": "typography",
      "$value": {
        "fontFamily": "{ref.fontFamily.sans}",
        "fontSize": "{ref.fontSize.32}",
        "fontWeight": "{ref.fontWeight.bold}",
        "lineHeight": "{ref.lineHeight.tight}"
      }
    }
  }
}
```

---

## Platform Outputs

Tokens are automatically transformed into platform-specific formats during the build process.

### Web (CSS Variables)

```css
/* Input token */
sys.color.action.primary.default

/* Output CSS */
--sys-color-action-primary-default: #0969da;
```

### JavaScript/TypeScript

```javascript
// Nested object structure
tokens.sys.color.action.primary.default // "#0969da"

// TypeScript types included
import { tokens } from '@theta/tokens';
```

### React Native

```javascript
// Flattened camelCase
sysColorActionPrimaryDefault // "#0969da"
```

---

## Quick Reference

### Build Commands

```bash
# Build all token formats
yarn workspace @theta/tokens build

# Watch mode for development
yarn workspace @theta/tokens build:watch
```

### Validation Rules

1. **Valid References** - All token references must point to existing tokens
2. **Type Consistency** - Values must match their declared type
3. **No Circular References** - Tokens cannot reference themselves directly or indirectly
4. **Tier Hierarchy** - Follow the one-way reference flow

### Troubleshooting

| Error | Cause | Solution |
|-------|-------|----------|
| Invalid reference | Token references non-existent token | Check token path and spelling |
| Circular reference | Tokens reference each other | Break the cycle, use primitives |
| Type mismatch | Wrong $type for value format | Match type to value structure |
| Missing $type | Literal value without type | Add $type to primitive tokens |

---

## Best Practices

1. **Use semantic tokens in components** - Components should rarely reference primitives directly
2. **Document token purpose** - Add $description to semantic and component tokens
3. **Follow naming patterns** - Consistency makes tokens predictable
4. **Test before committing** - Always run build to catch errors
5. **Think about themes** - Semantic tokens enable theme switching

## Next Steps

- Browse existing tokens in the sidebar under "Token Reference"
- Review component examples to see tokens in use
- Create a test token following this guide
- Join discussions about token architecture improvements